<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. The import system &mdash; Python 3.3.6 documentation</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.3.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 3.3.6 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.3.6 documentation" href="../index.html" />
    <link rel="up" title="The Python Language Reference" href="index.html" />
    <link rel="next" title="6. Expressions" href="expressions.html" />
    <link rel="prev" title="4. Execution model" href="executionmodel.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    
 

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. Expressions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Execution model"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <a href="../index.html">3.3.6 Documentation</a> &raquo;
        </li>

          <li><a href="index.html" accesskey="U">The Python Language Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-import-system">
<span id="importsystem"></span><h1>5. The import system<a class="headerlink" href="#the-import-system" title="Permalink to this headline">¶</a></h1>
<p id="index-0">Python code in one <a class="reference internal" href="../glossary.html#term-module"><em class="xref std std-term">module</em></a> gains access to the code in another module
by the process of <a class="reference internal" href="../glossary.html#term-importing"><em class="xref std std-term">importing</em></a> it.  The <a class="reference internal" href="simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement is
the most common way of invoking the import machinery, but it is not the only
way.  Functions such as <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><tt class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></tt></a> and built-in
<a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> can also be used to invoke the import machinery.</p>
<p>The <a class="reference internal" href="simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement combines two operations; it searches for the
named module, then it binds the results of that search to a name in the local
scope.  The search operation of the <a class="reference internal" href="simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement is defined as
a call to the <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> function, with the appropriate arguments.
The return value of <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> is used to perform the name
binding operation of the <a class="reference internal" href="simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement.  See the
<a class="reference internal" href="simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement for the exact details of that name binding
operation.</p>
<p>A direct call to <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> performs only the module search and, if
found, the module creation operation.  While certain side-effects may occur,
such as the importing of parent packages, and the updating of various caches
(including <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>), only the <a class="reference internal" href="simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement performs
a name binding operation.</p>
<p>When calling <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> as part of an import statement, the
import system first checks the module global namespace for a function by
that name. If it is not found, then the standard builtin <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a>
is called. Other mechanisms for invoking the import system (such as
<a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><tt class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></tt></a>) do not perform this check and will always
use the standard import system.</p>
<p>When a module is first imported, Python searches for the module and if found,
it creates a module object <a class="footnote-reference" href="#fnmo" id="id1">[1]</a>, initializing it.  If the named module
cannot be found, an <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised.  Python implements various
strategies to search for the named module when the import machinery is
invoked.  These strategies can be modified and extended by using various hooks
described in the sections below.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>The import system has been updated to fully implement the second phase
of <span class="target" id="index-1"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>. There is no longer any implicit import machinery - the full
import system is exposed through <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a>. In addition,
native namespace package support has been implemented (see <span class="target" id="index-2"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a>).</p>
</div>
<div class="section" id="importlib">
<h2>5.1. <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><tt class="xref py py-mod docutils literal"><span class="pre">importlib</span></tt></a><a class="headerlink" href="#importlib" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><tt class="xref py py-mod docutils literal"><span class="pre">importlib</span></tt></a> module provides a rich API for interacting with the
import system.  For example <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><tt class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></tt></a> provides a
recommended, simpler API than built-in <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> for invoking the
import machinery.  Refer to the <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><tt class="xref py py-mod docutils literal"><span class="pre">importlib</span></tt></a> library documentation for
additional detail.</p>
</div>
<div class="section" id="packages">
<h2>5.2. Packages<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h2>
<p id="index-3">Python has only one type of module object, and all modules are of this type,
regardless of whether the module is implemented in Python, C, or something
else.  To help organize modules and provide a naming hierarchy, Python has a
concept of <a class="reference internal" href="../glossary.html#term-package"><em class="xref std std-term">packages</em></a>.</p>
<p>You can think of packages as the directories on a file system and modules as
files within directories, but don&#8217;t take this analogy too literally since
packages and modules need not originate from the file system.  For the
purposes of this documentation, we&#8217;ll use this convenient analogy of
directories and files.  Like file system directories, packages are organized
hierarchically, and packages may themselves contain subpackages, as well as
regular modules.</p>
<p>It&#8217;s important to keep in mind that all packages are modules, but not all
modules are packages.  Or put another way, packages are just a special kind of
module.  Specifically, any module that contains a <tt class="docutils literal"><span class="pre">__path__</span></tt> attribute is
considered a package.</p>
<p>All modules have a name.  Subpackage names are separated from their parent
package name by dots, akin to Python&#8217;s standard attribute access syntax.  Thus
you might have a module called <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a> and a package called <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><tt class="xref py py-mod docutils literal"><span class="pre">email</span></tt></a>,
which in turn has a subpackage called <a class="reference internal" href="../library/email.mime.html#module-email.mime" title="email.mime: Build MIME messages."><tt class="xref py py-mod docutils literal"><span class="pre">email.mime</span></tt></a> and a module within
that subpackage called <tt class="xref py py-mod docutils literal"><span class="pre">email.mime.text</span></tt>.</p>
<div class="section" id="regular-packages">
<h3>5.2.1. Regular packages<a class="headerlink" href="#regular-packages" title="Permalink to this headline">¶</a></h3>
<p id="index-4">Python defines two types of packages, <a class="reference internal" href="../glossary.html#term-regular-package"><em class="xref std std-term">regular packages</em></a> and <a class="reference internal" href="../glossary.html#term-namespace-package"><em class="xref std std-term">namespace packages</em></a>.  Regular
packages are traditional packages as they existed in Python 3.2 and earlier.
A regular package is typically implemented as a directory containing an
<tt class="docutils literal"><span class="pre">__init__.py</span></tt> file.  When a regular package is imported, this
<tt class="docutils literal"><span class="pre">__init__.py</span></tt> file is implicitly executed, and the objects it defines are
bound to names in the package&#8217;s namespace.  The <tt class="docutils literal"><span class="pre">__init__.py</span></tt> file can
contain the same Python code that any other module can contain, and Python
will add some additional attributes to the module when it is imported.</p>
<p>For example, the following file system layout defines a top level <tt class="docutils literal"><span class="pre">parent</span></tt>
package with three subpackages:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">parent</span><span class="o">/</span>
    <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">one</span><span class="o">/</span>
        <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">two</span><span class="o">/</span>
        <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">three</span><span class="o">/</span>
        <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Importing <tt class="docutils literal"><span class="pre">parent.one</span></tt> will implicitly execute <tt class="docutils literal"><span class="pre">parent/__init__.py</span></tt> and
<tt class="docutils literal"><span class="pre">parent/one/__init__.py</span></tt>.  Subsequent imports of <tt class="docutils literal"><span class="pre">parent.two</span></tt> or
<tt class="docutils literal"><span class="pre">parent.three</span></tt> will execute <tt class="docutils literal"><span class="pre">parent/two/__init__.py</span></tt> and
<tt class="docutils literal"><span class="pre">parent/three/__init__.py</span></tt> respectively.</p>
</div>
<div class="section" id="namespace-packages">
<h3>5.2.2. Namespace packages<a class="headerlink" href="#namespace-packages" title="Permalink to this headline">¶</a></h3>
<p id="index-5">A namespace package is a composite of various <a class="reference internal" href="../glossary.html#term-portion"><em class="xref std std-term">portions</em></a>,
where each portion contributes a subpackage to the parent package.  Portions
may reside in different locations on the file system.  Portions may also be
found in zip files, on the network, or anywhere else that Python searches
during import.  Namespace packages may or may not correspond directly to
objects on the file system; they may be virtual modules that have no concrete
representation.</p>
<p>Namespace packages do not use an ordinary list for their <tt class="docutils literal"><span class="pre">__path__</span></tt>
attribute. They instead use a custom iterable type which will automatically
perform a new search for package portions on the next import attempt within
that package if the path of their parent package (or <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> for a
top level package) changes.</p>
<p>With namespace packages, there is no <tt class="docutils literal"><span class="pre">parent/__init__.py</span></tt> file.  In fact,
there may be multiple <tt class="docutils literal"><span class="pre">parent</span></tt> directories found during import search, where
each one is provided by a different portion.  Thus <tt class="docutils literal"><span class="pre">parent/one</span></tt> may not be
physically located next to <tt class="docutils literal"><span class="pre">parent/two</span></tt>.  In this case, Python will create a
namespace package for the top-level <tt class="docutils literal"><span class="pre">parent</span></tt> package whenever it or one of
its subpackages is imported.</p>
<p>See also <span class="target" id="index-6"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> for the namespace package specification.</p>
</div>
</div>
<div class="section" id="searching">
<h2>5.3. Searching<a class="headerlink" href="#searching" title="Permalink to this headline">¶</a></h2>
<p>To begin the search, Python needs the <a class="reference internal" href="../glossary.html#term-qualified-name"><em class="xref std std-term">fully qualified</em></a>
name of the module (or package, but for the purposes of this discussion, the
difference is immaterial) being imported.  This name may come from various
arguments to the <a class="reference internal" href="simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement, or from the parameters to the
<a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><tt class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></tt></a> or <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> functions.</p>
<p>This name will be used in various phases of the import search, and it may be
the dotted path to a submodule, e.g. <tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt>.  In this case, Python
first tries to import <tt class="docutils literal"><span class="pre">foo</span></tt>, then <tt class="docutils literal"><span class="pre">foo.bar</span></tt>, and finally <tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt>.
If any of the intermediate imports fail, an <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised.</p>
<div class="section" id="the-module-cache">
<h3>5.3.1. The module cache<a class="headerlink" href="#the-module-cache" title="Permalink to this headline">¶</a></h3>
<p id="index-7">The first place checked during import search is <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>.  This
mapping serves as a cache of all modules that have been previously imported,
including the intermediate paths.  So if <tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt> was previously
imported, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> will contain entries for <tt class="docutils literal"><span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">foo.bar</span></tt>,
and <tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt>.  Each key will have as its value the corresponding module
object.</p>
<p>During import, the module name is looked up in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> and if
present, the associated value is the module satisfying the import, and the
process completes.  However, if the value is <tt class="docutils literal"><span class="pre">None</span></tt>, then an
<a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised.  If the module name is missing, Python will
continue searching for the module.</p>
<p><a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> is writable.  Deleting a key may not destroy the
associated module (as other modules may hold references to it),
but it will invalidate the cache entry for the named module, causing
Python to search anew for the named module upon its next
import. The key can also be assigned to <tt class="docutils literal"><span class="pre">None</span></tt>, forcing the next import
of the module to result in an <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a>.</p>
<p>Beware though, as if you keep a reference to the module object,
invalidate its cache entry in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>, and then re-import the
named module, the two module objects will <em>not</em> be the same. By contrast,
<a class="reference internal" href="../library/imp.html#imp.reload" title="imp.reload"><tt class="xref py py-func docutils literal"><span class="pre">imp.reload()</span></tt></a> will reuse the <em>same</em> module object, and simply
reinitialise the module contents by rerunning the module&#8217;s code.</p>
</div>
<div class="section" id="finders-and-loaders">
<h3>5.3.2. Finders and loaders<a class="headerlink" href="#finders-and-loaders" title="Permalink to this headline">¶</a></h3>
<p id="index-8">If the named module is not found in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>, then Python&#8217;s import
protocol is invoked to find and load the module.  This protocol consists of
two conceptual objects, <a class="reference internal" href="../glossary.html#term-finder"><em class="xref std std-term">finders</em></a> and <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loaders</em></a>.
A finder&#8217;s job is to determine whether it can find the named module using
whatever strategy it knows about. Objects that implement both of these
interfaces are referred to as <a class="reference internal" href="../glossary.html#term-importer"><em class="xref std std-term">importers</em></a> - they return
themselves when they find that they can load the requested module.</p>
<p>Python includes a number of default finders and importers.  The first one
knows how to locate built-in modules, and the second knows how to locate
frozen modules.  A third default finder searches an <a class="reference internal" href="../glossary.html#term-import-path"><em class="xref std std-term">import path</em></a>
for modules.  The <a class="reference internal" href="../glossary.html#term-import-path"><em class="xref std std-term">import path</em></a> is a list of locations that may
name file system paths or zip files.  It can also be extended to search
for any locatable resource, such as those identified by URLs.</p>
<p>The import machinery is extensible, so new finders can be added to extend the
range and scope of module searching.</p>
<p>Finders do not actually load modules.  If they can find the named module, they
return a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a>, which the import machinery then invokes to load the
module and create the corresponding module object.</p>
<p>The following sections describe the protocol for finders and loaders in more
detail, including how you can create and register new ones to extend the
import machinery.</p>
</div>
<div class="section" id="import-hooks">
<h3>5.3.3. Import hooks<a class="headerlink" href="#import-hooks" title="Permalink to this headline">¶</a></h3>
<p id="index-9">The import machinery is designed to be extensible; the primary mechanism for
this are the <em>import hooks</em>.  There are two types of import hooks: <em>meta
hooks</em> and <em>import path hooks</em>.</p>
<p>Meta hooks are called at the start of import processing, before any other
import processing has occurred, other than <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> cache look up.
This allows meta hooks to override <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> processing, frozen
modules, or even built-in modules.  Meta hooks are registered by adding new
finder objects to <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a>, as described below.</p>
<p>Import path hooks are called as part of <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> (or
<tt class="docutils literal"><span class="pre">package.__path__</span></tt>) processing, at the point where their associated path
item is encountered.  Import path hooks are registered by adding new callables
to <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a> as described below.</p>
</div>
<div class="section" id="the-meta-path">
<h3>5.3.4. The meta path<a class="headerlink" href="#the-meta-path" title="Permalink to this headline">¶</a></h3>
<p id="index-10">When the named module is not found in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>, Python next
searches <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a>, which contains a list of meta path finder
objects.  These finders are queried in order to see if they know how to handle
the named module.  Meta path finders must implement a method called
<tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> which takes two arguments, a name and an import path.
The meta path finder can use any strategy it wants to determine whether it can
handle the named module or not.</p>
<p>If the meta path finder knows how to handle the named module, it returns a
loader object.  If it cannot handle the named module, it returns <tt class="docutils literal"><span class="pre">None</span></tt>.  If
<a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a> processing reaches the end of its list without returning
a loader, then an <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised.  Any other exceptions raised
are simply propagated up, aborting the import process.</p>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> method of meta path finders is called with two
arguments.  The first is the fully qualified name of the module being
imported, for example <tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt>.  The second argument is the path
entries to use for the module search.  For top-level modules, the second
argument is <tt class="docutils literal"><span class="pre">None</span></tt>, but for submodules or subpackages, the second
argument is the value of the parent package&#8217;s <tt class="docutils literal"><span class="pre">__path__</span></tt> attribute. If
the appropriate <tt class="docutils literal"><span class="pre">__path__</span></tt> attribute cannot be accessed, an
<a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised.</p>
<p>The meta path may be traversed multiple times for a single import request.
For example, assuming none of the modules involved has already been cached,
importing <tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt> will first perform a top level import, calling
<tt class="docutils literal"><span class="pre">mpf.find_module(&quot;foo&quot;,</span> <span class="pre">None)</span></tt> on each meta path finder (<tt class="docutils literal"><span class="pre">mpf</span></tt>). After
<tt class="docutils literal"><span class="pre">foo</span></tt> has been imported, <tt class="docutils literal"><span class="pre">foo.bar</span></tt> will be imported by traversing the
meta path a second time, calling
<tt class="docutils literal"><span class="pre">mpf.find_module(&quot;foo.bar&quot;,</span> <span class="pre">foo.__path__)</span></tt>. Once <tt class="docutils literal"><span class="pre">foo.bar</span></tt> has been
imported, the final traversal will call
<tt class="docutils literal"><span class="pre">mpf.find_module(&quot;foo.bar.baz&quot;,</span> <span class="pre">foo.bar.__path__)</span></tt>.</p>
<p>Some meta path finders only support top level imports. These importers will
always return <tt class="docutils literal"><span class="pre">None</span></tt> when anything other than <tt class="docutils literal"><span class="pre">None</span></tt> is passed as the
second argument.</p>
<p>Python&#8217;s default <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a> has three meta path finders, one that
knows how to import built-in modules, one that knows how to import frozen
modules, and one that knows how to import modules from an <a class="reference internal" href="../glossary.html#term-import-path"><em class="xref std std-term">import path</em></a>
(i.e. the <a class="reference internal" href="../glossary.html#term-path-based-finder"><em class="xref std std-term">path based finder</em></a>).</p>
</div>
</div>
<div class="section" id="loaders">
<h2>5.4. Loaders<a class="headerlink" href="#loaders" title="Permalink to this headline">¶</a></h2>
<p>If and when a module loader is found its
<a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><tt class="xref py py-meth docutils literal"><span class="pre">load_module()</span></tt></a> method is called, with a single
argument, the fully qualified name of the module being imported.  This method
has several responsibilities, and should return the module object it has
loaded <a class="footnote-reference" href="#fnlo" id="id2">[2]</a>.  If it cannot load the module, it should raise an
<a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a>, although any other exception raised during
<tt class="xref py py-meth docutils literal"><span class="pre">load_module()</span></tt> will be propagated.</p>
<p>In many cases, the finder and loader can be the same object; in such cases the
<tt class="xref py py-meth docutils literal"><span class="pre">finder.find_module()</span></tt> would just return <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Loaders must satisfy the following requirements:</p>
<blockquote>
<div><ul>
<li><p class="first">If there is an existing module object with the given name in
<a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>, the loader must use that existing module.  (Otherwise,
<a class="reference internal" href="../library/imp.html#imp.reload" title="imp.reload"><tt class="xref py py-func docutils literal"><span class="pre">imp.reload()</span></tt></a> will not work correctly.)  If the named module does
not exist in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>, the loader must create a new module
object and add it to <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>.</p>
<p>Note that the module <em>must</em> exist in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> before the loader
executes the module code.  This is crucial because the module code may
(directly or indirectly) import itself; adding it to <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>
beforehand prevents unbounded recursion in the worst case and multiple
loading in the best.</p>
<p>If loading fails, the loader must remove any modules it has inserted into
<a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>, but it must remove <strong>only</strong> the failing module, and
only if the loader itself has loaded it explicitly.  Any module already in
the <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> cache, and any module that was successfully loaded
as a side-effect, must remain in the cache.</p>
</li>
<li><p class="first">The loader may set the <tt class="docutils literal"><span class="pre">__file__</span></tt> attribute of the module.  If set, this
attribute&#8217;s value must be a string.  The loader may opt to leave
<tt class="docutils literal"><span class="pre">__file__</span></tt> unset if it has no semantic meaning (e.g. a module loaded from
a database). If <tt class="docutils literal"><span class="pre">__file__</span></tt> is set, it may also be appropriate to set the
<tt class="docutils literal"><span class="pre">__cached__</span></tt> attribute which is the path to any compiled version of the
code (e.g. byte-compiled file). The file does not need to exist to set this
attribute; the path can simply point to whether the compiled file would
exist (see <span class="target" id="index-11"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>).</p>
</li>
<li><p class="first">The loader may set the <tt class="docutils literal"><span class="pre">__name__</span></tt> attribute of the module.  While not
required, setting this attribute is highly recommended so that the
<a class="reference internal" href="../library/functions.html#repr" title="repr"><tt class="xref py py-meth docutils literal"><span class="pre">repr()</span></tt></a> of the module is more informative.</p>
</li>
<li><p class="first">If the module is a package (either regular or namespace), the loader must
set the module object&#8217;s <tt class="docutils literal"><span class="pre">__path__</span></tt> attribute.  The value must be
iterable, but may be empty if <tt class="docutils literal"><span class="pre">__path__</span></tt> has no further significance
to the loader. If <tt class="docutils literal"><span class="pre">__path__</span></tt> is not empty, it must produce strings
when iterated over. More details on the semantics of <tt class="docutils literal"><span class="pre">__path__</span></tt> are
given <a class="reference internal" href="#package-path-rules"><em>below</em></a>.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">__loader__</span></tt> attribute must be set to the loader object that loaded
the module.  This is mostly for introspection and reloading, but can be
used for additional loader-specific functionality, for example getting
data associated with a loader.</p>
</li>
<li><p class="first">The module&#8217;s <tt class="docutils literal"><span class="pre">__package__</span></tt> attribute should be set.  Its value must be a
string, but it can be the same value as its <tt class="docutils literal"><span class="pre">__name__</span></tt>.  If the attribute
is set to <tt class="docutils literal"><span class="pre">None</span></tt> or is missing, the import system will fill it in with a
more appropriate value.  When the module is a package, its <tt class="docutils literal"><span class="pre">__package__</span></tt>
value should be set to its <tt class="docutils literal"><span class="pre">__name__</span></tt>.  When the module is not a package,
<tt class="docutils literal"><span class="pre">__package__</span></tt> should be set to the empty string for top-level modules, or
for submodules, to the parent package&#8217;s name.  See <span class="target" id="index-12"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> for further
details.</p>
<p>This attribute is used instead of <tt class="docutils literal"><span class="pre">__name__</span></tt> to calculate explicit
relative imports for main modules, as defined in <span class="target" id="index-13"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a>.</p>
</li>
<li><p class="first">If the module is a Python module (as opposed to a built-in module or a
dynamically loaded extension), the loader should execute the module&#8217;s code
in the module&#8217;s global name space (<tt class="docutils literal"><span class="pre">module.__dict__</span></tt>).</p>
</li>
</ul>
</div></blockquote>
<div class="section" id="module-reprs">
<h3>5.4.1. Module reprs<a class="headerlink" href="#module-reprs" title="Permalink to this headline">¶</a></h3>
<p>By default, all modules have a usable repr, however depending on the
attributes set above, and hooks in the loader, you can more explicitly control
the repr of module objects.</p>
<p>Loaders may implement a <tt class="xref py py-meth docutils literal"><span class="pre">module_repr()</span></tt> method which takes a single
argument, the module object.  When <tt class="docutils literal"><span class="pre">repr(module)</span></tt> is called for a module
with a loader supporting this protocol, whatever is returned from
<tt class="docutils literal"><span class="pre">module.__loader__.module_repr(module)</span></tt> is returned as the module&#8217;s repr
without further processing.  This return value must be a string.</p>
<p>If the module has no <tt class="docutils literal"><span class="pre">__loader__</span></tt> attribute, or the loader has no
<tt class="xref py py-meth docutils literal"><span class="pre">module_repr()</span></tt> method, then the module object implementation itself
will craft a default repr using whatever information is available.  It will
try to use the <tt class="docutils literal"><span class="pre">module.__name__</span></tt>, <tt class="docutils literal"><span class="pre">module.__file__</span></tt>, and
<tt class="docutils literal"><span class="pre">module.__loader__</span></tt> as input into the repr, with defaults for whatever
information is missing.</p>
<p>Here are the exact rules used:</p>
<blockquote>
<div><ul class="simple">
<li>If the module has a <tt class="docutils literal"><span class="pre">__loader__</span></tt> and that loader has a
<tt class="xref py py-meth docutils literal"><span class="pre">module_repr()</span></tt> method, call it with a single argument, which is the
module object.  The value returned is used as the module&#8217;s repr.</li>
<li>If an exception occurs in <tt class="xref py py-meth docutils literal"><span class="pre">module_repr()</span></tt>, the exception is caught
and discarded, and the calculation of the module&#8217;s repr continues as if
<tt class="xref py py-meth docutils literal"><span class="pre">module_repr()</span></tt> did not exist.</li>
<li>If the module has a <tt class="docutils literal"><span class="pre">__file__</span></tt> attribute, this is used as part of the
module&#8217;s repr.</li>
<li>If the module has no <tt class="docutils literal"><span class="pre">__file__</span></tt> but does have a <tt class="docutils literal"><span class="pre">__loader__</span></tt>, then the
loader&#8217;s repr is used as part of the module&#8217;s repr.</li>
<li>Otherwise, just use the module&#8217;s <tt class="docutils literal"><span class="pre">__name__</span></tt> in the repr.</li>
</ul>
</div></blockquote>
<p>This example, from <span class="target" id="index-14"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> shows how a loader can craft its own module
repr:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NamespaceLoader</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;module &#39;{}&#39; (namespace)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="module-path">
<span id="package-path-rules"></span><h3>5.4.2. module.__path__<a class="headerlink" href="#module-path" title="Permalink to this headline">¶</a></h3>
<p>By definition, if a module has an <tt class="docutils literal"><span class="pre">__path__</span></tt> attribute, it is a package,
regardless of its value.</p>
<p>A package&#8217;s <tt class="docutils literal"><span class="pre">__path__</span></tt> attribute is used during imports of its subpackages.
Within the import machinery, it functions much the same as <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a>,
i.e. providing a list of locations to search for modules during import.
However, <tt class="docutils literal"><span class="pre">__path__</span></tt> is typically much more constrained than
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a>.</p>
<p><tt class="docutils literal"><span class="pre">__path__</span></tt> must be an iterable of strings, but it may be empty.
The same rules used for <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> also apply to a package&#8217;s
<tt class="docutils literal"><span class="pre">__path__</span></tt>, and <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a> (described below) are
consulted when traversing a package&#8217;s <tt class="docutils literal"><span class="pre">__path__</span></tt>.</p>
<p>A package&#8217;s <tt class="docutils literal"><span class="pre">__init__.py</span></tt> file may set or alter the package&#8217;s <tt class="docutils literal"><span class="pre">__path__</span></tt>
attribute, and this was typically the way namespace packages were implemented
prior to <span class="target" id="index-15"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a>.  With the adoption of <span class="target" id="index-16"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a>, namespace packages no
longer need to supply <tt class="docutils literal"><span class="pre">__init__.py</span></tt> files containing only <tt class="docutils literal"><span class="pre">__path__</span></tt>
manipulation code; the namespace loader automatically sets <tt class="docutils literal"><span class="pre">__path__</span></tt>
correctly for the namespace package.</p>
</div>
</div>
<div class="section" id="the-path-based-finder">
<h2>5.5. The Path Based Finder<a class="headerlink" href="#the-path-based-finder" title="Permalink to this headline">¶</a></h2>
<p id="index-17">As mentioned previously, Python comes with several default meta path finders.
One of these, called the <a class="reference internal" href="../glossary.html#term-path-based-finder"><em class="xref std std-term">path based finder</em></a>, searches an <a class="reference internal" href="../glossary.html#term-import-path"><em class="xref std std-term">import
path</em></a>, which contains a list of <a class="reference internal" href="../glossary.html#term-path-entry"><em class="xref std std-term">path entries</em></a>.  Each path
entry names a location to search for modules.</p>
<p>The path based finder itself doesn&#8217;t know how to import anything. Instead, it
traverses the individual path entries, associating each of them with a
path entry finder that knows how to handle that particular kind of path.</p>
<p>The default set of path entry finders implement all the semantics for finding
modules on the file system, handling special file types such as Python source
code (<tt class="docutils literal"><span class="pre">.py</span></tt> files), Python byte code (<tt class="docutils literal"><span class="pre">.pyc</span></tt> and <tt class="docutils literal"><span class="pre">.pyo</span></tt> files) and
shared libraries (e.g. <tt class="docutils literal"><span class="pre">.so</span></tt> files). When supported by the <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: support for importing Python modules from ZIP archives."><tt class="xref py py-mod docutils literal"><span class="pre">zipimport</span></tt></a>
module in the standard library, the default path entry finders also handle
loading all of these file types (other than shared libraries) from zipfiles.</p>
<p>Path entries need not be limited to file system locations.  They can refer to
URLs, database queries, or any other location that can be specified as a
string.</p>
<p>The path based finder provides additional hooks and protocols so that you
can extend and customize the types of searchable path entries.  For example,
if you wanted to support path entries as network URLs, you could write a hook
that implements HTTP semantics to find modules on the web.  This hook (a
callable) would return a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path entry finder</em></a> supporting the protocol
described below, which was then used to get a loader for the module from the
web.</p>
<p>A word of warning: this section and the previous both use the term <em>finder</em>,
distinguishing between them by using the terms <a class="reference internal" href="../glossary.html#term-meta-path-finder"><em class="xref std std-term">meta path finder</em></a> and
<a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path entry finder</em></a>.  These two types of finders are very similar,
support similar protocols, and function in similar ways during the import
process, but it&#8217;s important to keep in mind that they are subtly different.
In particular, meta path finders operate at the beginning of the import
process, as keyed off the <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a> traversal.</p>
<p>By contrast, path entry finders are in a sense an implementation detail
of the path based finder, and in fact, if the path based finder were to be
removed from <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a>, none of the path entry finder semantics
would be invoked.</p>
<div class="section" id="path-entry-finders">
<h3>5.5.1. Path entry finders<a class="headerlink" href="#path-entry-finders" title="Permalink to this headline">¶</a></h3>
<p id="index-18">The <a class="reference internal" href="../glossary.html#term-path-based-finder"><em class="xref std std-term">path based finder</em></a> is responsible for finding and loading Python
modules and packages whose location is specified with a string <a class="reference internal" href="../glossary.html#term-path-entry"><em class="xref std std-term">path
entry</em></a>.  Most path entries name locations in the file system, but they need
not be limited to this.</p>
<p>As a meta path finder, the <a class="reference internal" href="../glossary.html#term-path-based-finder"><em class="xref std std-term">path based finder</em></a> implements the
<tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> protocol previously described, however it exposes
additional hooks that can be used to customize how modules are found and
loaded from the <a class="reference internal" href="../glossary.html#term-import-path"><em class="xref std std-term">import path</em></a>.</p>
<p>Three variables are used by the <a class="reference internal" href="../glossary.html#term-path-based-finder"><em class="xref std std-term">path based finder</em></a>, <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a>,
<a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a> and <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a>.  The <tt class="docutils literal"><span class="pre">__path__</span></tt>
attributes on package objects are also used.  These provide additional ways
that the import machinery can be customized.</p>
<p><a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> contains a list of strings providing search locations for
modules and packages.  It is initialized from the <tt class="xref py py-data docutils literal"><span class="pre">PYTHONPATH</span></tt>
environment variable and various other installation- and
implementation-specific defaults.  Entries in <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> can name
directories on the file system, zip files, and potentially other &#8220;locations&#8221;
(see the <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a> module) that should be searched for modules, such as
URLs, or database queries.  Only strings and bytes should be present on
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a>; all other data types are ignored.  The encoding of bytes
entries is determined by the individual <a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path entry finders</em></a>.</p>
<p>The <a class="reference internal" href="../glossary.html#term-path-based-finder"><em class="xref std std-term">path based finder</em></a> is a <a class="reference internal" href="../glossary.html#term-meta-path-finder"><em class="xref std std-term">meta path finder</em></a>, so the import
machinery begins the <a class="reference internal" href="../glossary.html#term-import-path"><em class="xref std std-term">import path</em></a> search by calling the path
based finder&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> method as described previously.  When
the <tt class="docutils literal"><span class="pre">path</span></tt> argument to <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> is given, it will be a
list of string paths to traverse - typically a package&#8217;s <tt class="docutils literal"><span class="pre">__path__</span></tt>
attribute for an import within that package.  If the <tt class="docutils literal"><span class="pre">path</span></tt> argument
is <tt class="docutils literal"><span class="pre">None</span></tt>, this indicates a top level import and <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> is used.</p>
<p>The path based finder iterates over every entry in the search path, and
for each of these, looks for an appropriate <a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path entry finder</em></a> for the
path entry.  Because this can be an expensive operation (e.g. there may be
<cite>stat()</cite> call overheads for this search), the path based finder maintains
a cache mapping path entries to path entry finders.  This cache is maintained
in <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a> (despite the name, this cache actually
stores finder objects rather than being limited to <a class="reference internal" href="../glossary.html#term-importer"><em class="xref std std-term">importer</em></a> objects).
In this way, the expensive search for a particular <a class="reference internal" href="../glossary.html#term-path-entry"><em class="xref std std-term">path entry</em></a>
location&#8217;s <a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path entry finder</em></a> need only be done once.  User code is
free to remove cache entries from <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a> forcing
the path based finder to perform the path entry search again <a class="footnote-reference" href="#fnpic" id="id3">[3]</a>.</p>
<p>If the path entry is not present in the cache, the path based finder iterates
over every callable in <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a>.  Each of the <a class="reference internal" href="../glossary.html#term-path-entry-hook"><em class="xref std std-term">path entry
hooks</em></a> in this list is called with a single argument, the
path entry to be searched.  This callable may either return a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path
entry finder</em></a> that can handle the path entry, or it may raise
<a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a>.  An <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is used by the path based finder to
signal that the hook cannot find a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path entry finder</em></a> for that
<a class="reference internal" href="../glossary.html#term-path-entry"><em class="xref std std-term">path entry</em></a>.  The exception is ignored and <a class="reference internal" href="../glossary.html#term-import-path"><em class="xref std std-term">import path</em></a>
iteration continues.  The hook should expect either a string or bytes object;
the encoding of bytes objects is up to the hook (e.g. it may be a file system
encoding, UTF-8, or something else), and if the hook cannot decode the
argument, it should raise <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a>.</p>
<p>If <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a> iteration ends with no <a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path entry finder</em></a>
being returned, then the path based finder&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> method
will store <tt class="docutils literal"><span class="pre">None</span></tt> in <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a> (to indicate that
there is no finder for this path entry) and return <tt class="docutils literal"><span class="pre">None</span></tt>, indicating that
this <a class="reference internal" href="../glossary.html#term-meta-path-finder"><em class="xref std std-term">meta path finder</em></a> could not find the module.</p>
<p>If a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><em class="xref std std-term">path entry finder</em></a> <em>is</em> returned by one of the <a class="reference internal" href="../glossary.html#term-path-entry-hook"><em class="xref std std-term">path entry
hook</em></a> callables on <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a>, then the following protocol is used
to ask the finder for a module loader, which is then used to load the module.</p>
</div>
<div class="section" id="path-entry-finder-protocol">
<h3>5.5.2. Path entry finder protocol<a class="headerlink" href="#path-entry-finder-protocol" title="Permalink to this headline">¶</a></h3>
<p>In order to support imports of modules and initialized packages and also to
contribute portions to namespace packages, path entry finders must implement
the <tt class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></tt> method.</p>
<p><tt class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></tt> takes one argument, the fully qualified name of the
module being imported.  <tt class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></tt> returns a 2-tuple where the
first item is the loader and the second item is a namespace <a class="reference internal" href="../glossary.html#term-portion"><em class="xref std std-term">portion</em></a>.
When the first item (i.e. the loader) is <tt class="docutils literal"><span class="pre">None</span></tt>, this means that while the
path entry finder does not have a loader for the named module, it knows that the
path entry contributes to a namespace portion for the named module.  This will
almost always be the case where Python is asked to import a namespace package
that has no physical presence on the file system.  When a path entry finder
returns <tt class="docutils literal"><span class="pre">None</span></tt> for the loader, the second item of the 2-tuple return value
must be a sequence, although it can be empty.</p>
<p>If <tt class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></tt> returns a non-<tt class="docutils literal"><span class="pre">None</span></tt> loader value, the portion is
ignored and the loader is returned from the path based finder, terminating
the search through the path entries.</p>
<p>For backwards compatibility with other implementations of the import
protocol, many path entry finders also support the same,
traditional <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> method that meta path finders support.
However path entry finder <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> methods are never called
with a <tt class="docutils literal"><span class="pre">path</span></tt> argument (they are expected to record the appropriate
path information from the initial call to the path hook).</p>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> method on path entry finders is deprecated,
as it does not allow the path entry finder to contribute portions to
namespace packages. Instead path entry finders should implement the
<tt class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></tt> method as described above. If it exists on the path
entry finder, the import system will always call <tt class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></tt>
in preference to <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt>.</p>
</div>
</div>
<div class="section" id="replacing-the-standard-import-system">
<h2>5.6. Replacing the standard import system<a class="headerlink" href="#replacing-the-standard-import-system" title="Permalink to this headline">¶</a></h2>
<p>The most reliable mechanism for replacing the entire import system is to
delete the default contents of <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a>, replacing them
entirely with a custom meta path hook.</p>
<p>If it is acceptable to only alter the behaviour of import statements
without affecting other APIs that access the import system, then replacing
the builtin <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> function may be sufficient. This technique
may also be employed at the module level to only alter the behaviour of
import statements within that module.</p>
<p>To selectively prevent import of some modules from a hook early on the
meta path (rather than disabling the standard import system entirely),
it is sufficient to raise <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> directly from
<tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> instead of returning <tt class="docutils literal"><span class="pre">None</span></tt>. The latter indicates
that the meta path search should continue. while raising an exception
terminates it immediately.</p>
</div>
<div class="section" id="open-issues">
<h2>5.7. Open issues<a class="headerlink" href="#open-issues" title="Permalink to this headline">¶</a></h2>
<p>XXX It would be really nice to have a diagram.</p>
<p>XXX * (import_machinery.rst) how about a section devoted just to the
attributes of modules and packages, perhaps expanding upon or supplanting the
related entries in the data model reference page?</p>
<p>XXX runpy, pkgutil, et al in the library manual should all get &#8220;See Also&#8221;
links at the top pointing to the new import system section.</p>
</div>
<div class="section" id="references">
<h2>5.8. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>The import machinery has evolved considerably since Python&#8217;s early days.  The
original <a class="reference external" href="http://www.python.org/doc/essays/packages.html">specification for packages</a> is still available to read,
although some details have changed since the writing of that document.</p>
<p>The original specification for <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a> was <span class="target" id="index-19"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>, with
subsequent extension in <span class="target" id="index-20"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a>.</p>
<p><span class="target" id="index-21"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> introduced <a class="reference internal" href="../glossary.html#term-namespace-package"><em class="xref std std-term">namespace packages</em></a> for
Python 3.3.  <span class="target" id="index-22"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> also introduced the <tt class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></tt> protocol as an
alternative to <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt>.</p>
<p><span class="target" id="index-23"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> describes the addition of the <tt class="docutils literal"><span class="pre">__package__</span></tt> attribute for
explicit relative imports in main modules.</p>
<p><span class="target" id="index-24"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> introduced absolute and explicit relative imports and initially
proposed <tt class="docutils literal"><span class="pre">__name__</span></tt> for semantics <span class="target" id="index-25"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> would eventually specify for
<tt class="docutils literal"><span class="pre">__package__</span></tt>.</p>
<p><span class="target" id="index-26"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0338"><strong>PEP 338</strong></a> defines executing modules as scripts.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="fnmo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>See <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><tt class="xref py py-class docutils literal"><span class="pre">types.ModuleType</span></tt></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnlo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>The importlib implementation avoids using the return value
directly. Instead, it gets the module object by looking the module name up
in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>.  The indirect effect of this is that an imported
module may replace itself in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>.  This is
implementation-specific behavior that is not guaranteed to work in other
Python implementations.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnpic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>In legacy code, it is possible to find instances of
<a class="reference internal" href="../library/imp.html#imp.NullImporter" title="imp.NullImporter"><tt class="xref py py-class docutils literal"><span class="pre">imp.NullImporter</span></tt></a> in the <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a>.  It
is recommended that code be changed to use <tt class="docutils literal"><span class="pre">None</span></tt> instead.  See
<a class="reference internal" href="../whatsnew/3.3.html#portingpythoncode"><em>Porting Python code</em></a> for more details.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. The import system</a><ul>
<li><a class="reference internal" href="#importlib">5.1. <tt class="docutils literal"><span class="pre">importlib</span></tt></a></li>
<li><a class="reference internal" href="#packages">5.2. Packages</a><ul>
<li><a class="reference internal" href="#regular-packages">5.2.1. Regular packages</a></li>
<li><a class="reference internal" href="#namespace-packages">5.2.2. Namespace packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#searching">5.3. Searching</a><ul>
<li><a class="reference internal" href="#the-module-cache">5.3.1. The module cache</a></li>
<li><a class="reference internal" href="#finders-and-loaders">5.3.2. Finders and loaders</a></li>
<li><a class="reference internal" href="#import-hooks">5.3.3. Import hooks</a></li>
<li><a class="reference internal" href="#the-meta-path">5.3.4. The meta path</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loaders">5.4. Loaders</a><ul>
<li><a class="reference internal" href="#module-reprs">5.4.1. Module reprs</a></li>
<li><a class="reference internal" href="#module-path">5.4.2. module.__path__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-path-based-finder">5.5. The Path Based Finder</a><ul>
<li><a class="reference internal" href="#path-entry-finders">5.5.1. Path entry finders</a></li>
<li><a class="reference internal" href="#path-entry-finder-protocol">5.5.2. Path entry finder protocol</a></li>
</ul>
</li>
<li><a class="reference internal" href="#replacing-the-standard-import-system">5.6. Replacing the standard import system</a></li>
<li><a class="reference internal" href="#open-issues">5.7. Open issues</a></li>
<li><a class="reference internal" href="#references">5.8. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="previous chapter">4. Execution model</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="expressions.html"
                        title="next chapter">6. Expressions</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/reference/import.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. Expressions"
             >next</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Execution model"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <a href="../index.html">3.3.6 Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Language Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2014, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Oct 12, 2014.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.
    </div>

  </body>
</html>